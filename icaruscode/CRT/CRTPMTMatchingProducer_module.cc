/**
 * @file   icaruscode/CRT/CRTPMTMatchingProducer_module.cc
 * @brief  Producer to extract and store time matches between CRT hits and PMT.
 * @author Francesco Poppi ( poppi@bo.infn.it )  and Anna Heggestuen 
 * @date   April 26 2023
 */

// icaruscode includes
#include "sbnobj/Common/CRT/CRTHit.hh"
#include "sbnobj/Common/Trigger/ExtraTriggerInfo.h"
#include "icaruscode/CRT/CRTUtils/CRTPMTMatchingUtils.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "canvas/Persistency/Common/FindMany.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// C++ includes
#include <memory>
#include <iomanip>
#include <vector>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "larcore/CoreUtils/ServiceUtil.h" // lar::providerFrom()
#include "larcorealg/Geometry/geo_vectors_utils.h" // MiddlePointAccumulator
#include "larcorealg/CoreUtils/enumerate.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"
#include "lardataobj/RecoBase/OpHit.h"
#include "lardataobj/RecoBase/OpFlash.h"


using std::vector;

namespace icarus::crt {

  class CRTPMTMatchingProducer : public art::EDProducer {
  public:
 
    using CRTHit = sbn::crt::CRTHit;
    
    explicit CRTPMTMatchingProducer(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Required functions.
    void produce(art::Event & e) override;

  private:

    // Params from fcl file.......

    std::vector<art::InputTag> const fFlashLabels;   ///< All optical flash input tags.
    art::InputTag const fCrtHitModuleLabel;          ///< Name of CRT producer.
    art::InputTag const fTriggerLabel;               ///< Name of trigger producer.
    
    double const fTimeOfFlightInterval;              ///< CRT-PMT time difference interval to find the match.
    int const fPMTADCThresh;                         ///< ADC amplitude for a PMT to be considered above threshold.
    int const fnOpHitToTrigger;                      ///< Number of OpHit above threshold to mimic the triggering PMT.
    double const fGlobalT0Offset;                    ///< 1.6 ms delay to shift CRT Hit T0, the CRT Timing variable we use in MC.

    double const fBNBBeamGateMin;
    double const fBNBBeamGateMax;
    double const fBNBinBeamMin;
    double const fBNBinBeamMax;
    double const fNuMIBeamGateMin;
    double const fNuMIBeamGateMax;
    double const fNuMIinBeamMin;
    double const fNuMIinBeamMax;

    geo::GeometryCore const* const fGeometryService;  ///< Pointer to Geometry provider.

  }; // class CRTPMTMatchingProducer

  CRTPMTMatchingProducer::CRTPMTMatchingProducer(fhicl::ParameterSet const & p)
  : EDProducer{p},
    fFlashLabels(p.get<std::vector<art::InputTag>>("OpFlashModuleLabels")),
    fCrtHitModuleLabel(p.get<art::InputTag>("CrtHitModuleLabel", "crthit")),
    fTriggerLabel(p.get<art::InputTag>("TriggerLabel", "daqTrigger")),
    fTimeOfFlightInterval(p.get<double>("TimeOfFlightInterval")),
    fPMTADCThresh(p.get<int>("PMTADCThresh")),
    fnOpHitToTrigger(p.get<int>("nOpHitToTrigger")),
    fGlobalT0Offset(p.get<int>("GlobalT0Offset")),
    fBNBBeamGateMin(p.get<double>("BNBBeamGateMin")),
    fBNBBeamGateMax(p.get<double>("BNBBeamGateMax")),
    fBNBinBeamMin(p.get<double>("BNBinBeamMin")),
    fBNBinBeamMax(p.get<double>("BNBinBeamMax")),
    fNuMIBeamGateMin(p.get<double>("NuMIBeamGateMin")),
    fNuMIBeamGateMax(p.get<double>("NuMIBeamGateMax")),
    fNuMIinBeamMin(p.get<double>("NuMIinBeamMin")),
    fNuMIinBeamMax(p.get<double>("NuMIinBeamMax")),
    fGeometryService(lar::providerFrom<geo::Geometry>())
  {
    produces< std::vector<CRTPMTMatching> >();
  } // CRTPMTMatchingProducer()


  void CRTPMTMatchingProducer::produce(art::Event & e)
  {
    mf::LogDebug("CRTPMTMatchingProducer") << "beginning CRTPMTProducer";
    // Trigger data product variables
    unsigned int m_gate_type = 0;
    uint64_t m_trigger_gate_diff = 0; // TODO: check what happens in case of failure to retrieve it
    // add trigger info
    if (!fTriggerLabel.empty()) {
      art::Handle<sbn::ExtraTriggerInfo> trigger_handle;
      e.getByLabel(fTriggerLabel, trigger_handle);
      if (trigger_handle.isValid()) {
        sbn::triggerSource bit = trigger_handle->sourceType;
        m_gate_type = (unsigned int)bit;
        m_trigger_gate_diff =
        trigger_handle->triggerTimestamp - trigger_handle->beamGateTimestamp;
      } else {
        mf::LogDebug("CRTPMTMatchingProducer") << "No sbn::ExtraTriggerInfo associated to label: " << fTriggerLabel.encode() << "\n";
      }
    }
    else {
      mf::LogDebug("CRTPMTMatchingProducer") << "No TriggerLabel in : " << fTriggerLabel.encode() << "\n";
    }
    
    std::unique_ptr< vector<CRTPMTMatching> > CRTPMTMatchesColl( new vector<CRTPMTMatching>);
    //std::unique_ptr< art::Assns<CRTPMTMatching, recob::OpFlash> > FlashAssociation( new art::Assns<CRTPMTMatching, recob::OpFlash>);
    // add CRTHits
    art::Handle<std::vector<CRTHit>> crtHitListHandle;
    std::vector<art::Ptr<CRTHit>> crtHitList;
    if (e.getByLabel(fCrtHitModuleLabel, crtHitListHandle))
      art::fill_ptr_vector(crtHitList, crtHitListHandle);
    bool isRealData = e.isRealData();
    mf::LogTrace("CRTPMTMatchingProducer") << "is this real data? " << std::boolalpha << isRealData;
    // add optical flashes
    for (art::InputTag const& flashLabel : fFlashLabels) {
    auto const flashHandle =
      e.getHandle<std::vector<recob::OpFlash>>(flashLabel);
    art::FindMany<recob::OpHit> findManyHits(flashHandle, e, flashLabel);

    std::vector<FlashType> thisEventFlashes;

    for (auto const& [iflash, flash] : util::enumerate(*flashHandle)) {
      MatchType eventType = others;
      double tflash = flash.Time();
      vector<recob::OpHit const*> const& hits = findManyHits.at(iflash);
      int nPMTsTriggering = 0;
      double firstTime = 999999;
      geo::vect::MiddlePointAccumulator flashCentroid;
      for (auto const& hit : hits) {
        if (hit->Amplitude() > fPMTADCThresh) nPMTsTriggering++;
        if (firstTime > hit->PeakTime()) firstTime = hit->PeakTime();
        geo::Point_t const pos =
          fGeometryService->OpDetGeoFromOpChannel(hit->OpChannel())
          .GetCenter();
        double amp = hit->Amplitude();
        flashCentroid.add(pos, amp);
      }
      geo::Point_t flash_pos = flashCentroid.middlePoint();
      if (nPMTsTriggering < fnOpHitToTrigger) continue;

      double fThisRelGateTime = m_trigger_gate_diff + tflash * 1e3;
      bool fThisInTime_gate = false;
      bool fThisInTime_beam = false;
      if (m_gate_type == 1 || m_gate_type == 3) {  // BNB OffBeamBNB
        if (fThisRelGateTime > fBNBBeamGateMin &&
              fThisRelGateTime < fBNBBeamGateMax)
              fThisInTime_gate = true;
        if (fThisRelGateTime > fBNBinBeamMin &&
              fThisRelGateTime < fBNBinBeamMax)
              fThisInTime_beam = true;
      }
      if (m_gate_type == 2 || m_gate_type == 4) {  // NuMI OffBeamNuMI
        if (fThisRelGateTime > fNuMIBeamGateMin &&
              fThisRelGateTime < fNuMIBeamGateMax)
              fThisInTime_gate = true;
        if (fThisRelGateTime > fNuMIinBeamMin &&
              fThisRelGateTime < fNuMIinBeamMax)
              fThisInTime_beam = true;
      }
      bool inTime = fThisInTime_gate;
      icarus::crt::CRTMatches crtMatches = CRTHitmatched(
        firstTime, flash_pos, crtHitList, fTimeOfFlightInterval, isRealData, fGlobalT0Offset);
      int TopEn = 0, TopEx = 0, SideEn = 0, SideEx = 0;      
      auto nCRTHits = crtMatches.entering.size() + crtMatches.exiting.size();
      
      std::vector<MatchedCRT> thisFlashCRTmatches;
      eventType = crtMatches.flashType;
      if (nCRTHits > 0) {
        mf::LogTrace("CRTPMTMatchingProducer") 
          << "nCRTMatches = nEntering + nExiting = " << crtMatches.entering.size() << " + " << crtMatches.exiting.size() << " = " << nCRTHits;
        for (auto const& entering : crtMatches.entering) {
          vector<double> CRTpos {entering.CRTHit->x_pos,
                                 entering.CRTHit->y_pos,
                                 entering.CRTHit->z_pos};
          geo::Point_t thisCRTpos {entering.CRTHit->x_pos,
                                   entering.CRTHit->y_pos,
                                   entering.CRTHit->z_pos};
          // fGlobalT0Offset = 1.6e6 ns = 1600000 ns. 
          double CRTtime_us = isRealData ? (entering.CRTHit->ts1_ns/1e3) : ( (long long)(entering.CRTHit->ts0()) - fGlobalT0Offset)/1e3; // us 
          double CRTtime_ns = isRealData ? (entering.CRTHit->ts1_ns) : ( (long long)(entering.CRTHit->ts0()) - fGlobalT0Offset); // us 
          mf::LogTrace("CRTPMTMatchingProducer") << "CRTTime_us = " << CRTtime_us << ", CRTtime_ns = " << CRTtime_ns;
          int CRTRegion = entering.CRTHit->plane;
          int CRTSys = 0;
          if (CRTRegion >= 36) CRTSys = 1;  // Very lazy way to determine if the Hit is a Top or a Side.
                                            // Will update it when bottom CRT will be availble.
          double CRTTof_opflash = CRTtime_ns - tflash * 1e3; // ns 
          double CRTTof_opflash_us = CRTtime_us - tflash; // us 
          mf::LogTrace("CRTPMTMatchingProducer") << "Entering match: tof = crtTime_ns - tflash*1e3 = " << CRTtime_ns << " - "<< tflash * 1e3 << " = " << CRTTof_opflash << " (ns)"
            << "\nEntering match: tof_us = crtTime_us - tflash  = " << CRTtime_us << " - "<< tflash << " = " << CRTTof_opflash_us << " (us)";
          std::vector<int> HitFebs;
          for (auto crts : entering.CRTHit->feb_id) {
            HitFebs.emplace_back((int)crts);
          }
          if (CRTSys == 0) TopEn++;
          if (CRTSys == 1) SideEn++;
          //matchedCRT thisCRTMatch = { /* .CRTHitPos = */ thisCRTpos, // C++20: restore initializers
          MatchedCRT thisCRTMatch = { /* .CRTHitPos = */ thisCRTpos, // C++20: restore initializers
                                      /* .CRTPMTTimeDiff_ns = */ CRTTof_opflash,
                                      /* .CRTTime_us = */ CRTtime_us,
                                      /* .CRTSys = */ CRTSys,
                                      /* .CRTRegion = */ CRTRegion};
          thisFlashCRTmatches.push_back(thisCRTMatch);
        }
        for (auto const& exiting : crtMatches.exiting) {
          vector<double> CRTpos {exiting.CRTHit->x_pos,
                                 exiting.CRTHit->y_pos,
                                 exiting.CRTHit->z_pos};
          geo::Point_t thisCRTpos {exiting.CRTHit->x_pos,
                                   exiting.CRTHit->y_pos,
                                   exiting.CRTHit->z_pos};
          double CRTtime_us = isRealData ? (exiting.CRTHit->ts1_ns/1e3) : ( (long long)(exiting.CRTHit->ts0()) - fGlobalT0Offset)/1e3; // us    
          double CRTtime_ns = isRealData ? (exiting.CRTHit->ts1_ns) : ( (long long)(exiting.CRTHit->ts0()) - fGlobalT0Offset); // us     
          mf::LogTrace("CRTPMTMatchingProducer") << isRealData << ", CRTTime_us = " << CRTtime_us << ", CRTtime_ns = " << CRTtime_ns;
          int CRTRegion = exiting.CRTHit->plane;
          int CRTSys = 0;
          if (CRTRegion >= 36) CRTSys = 1; 
          double CRTTof_opflash = CRTtime_ns - tflash * 1e3; // ns
          double CRTTof_opflash_us = CRTtime_us - tflash; // us
          mf::LogTrace("CRTPMTMatchingProducer")
            << "Exiting match: tof = crtTime_ns - tflash*1e3 = " << CRTtime_ns << " - "<< tflash * 1e3 << " = " << CRTTof_opflash << " (ns)"
            << "\nExiting match: tof_us = crtTime_us - tflash  = " << CRTtime_us << " - "<< tflash << " = " << CRTTof_opflash_us << " (us)";
          std::vector<int> HitFebs;
          for (auto crts : exiting.CRTHit->feb_id) {
            HitFebs.emplace_back((int)crts);
          }
          if (CRTSys == 0) TopEx++;
          if (CRTSys == 1) SideEx++;
          MatchedCRT thisCRTMatch = { /* .CRTHitPos =*/  thisCRTpos, // C++20: restore initializers
                                      /* .CRTPMTTimeDiff_ns = */ CRTTof_opflash,
                                      /* .CRTTime_us = */ CRTtime_us,
                                      /* .CRTSys = */ CRTSys,
                                      /* .CRTRegion = */ CRTRegion};
          thisFlashCRTmatches.push_back(thisCRTMatch);
        }
      } //Fine CRT
      FlashType thisFlashType = { /* .flashPos = */ flash_pos, // C++20: restore initializers
                                  /* .flashTime_us = */ tflash,
                                  /* .flashGateTime_ns = */ fThisRelGateTime,
                                  /* .inBeam = */ fThisInTime_beam,
                                  /* .inGate = */ inTime,
                                  /* .classification = */ eventType,
                                  /* .CRTmatches = */ thisFlashCRTmatches};
      thisEventFlashes.push_back(thisFlashType);
      if (!thisFlashCRTmatches.empty() )
        mf::LogTrace("CRTPMTMatchingProducer") << "pushing back flash with " << thisFlashCRTmatches.size() << " CRT Matches.";
    } // end of this flash
    mf::LogTrace("CRTPMTMatchingProducer") << "Event has " << thisEventFlashes.size() << " flashes in " << flashLabel.encode();
    for (auto const& theseFlashes : thisEventFlashes){
      CRTPMTMatching ProducedFlash = FillCRTPMT (theseFlashes, e.id().event(), e.run(), m_gate_type);
      CRTPMTMatchesColl->push_back(ProducedFlash);  
    }
  }
   //art::PtrMaker<sbn::crt::CRTHit> makeHitPtr(event);
  mf::LogTrace("CRTPMTMatchingProducer") <<"This Event has "<<CRTPMTMatchesColl->size()<<"  Flashes candidate for CRT matching."<<std::endl;
    e.put(std::move(CRTPMTMatchesColl));
    //e.put(std::move(FlashAssociation));

  } // CRTPMTMatchingProducer::produce()


  DEFINE_ART_MODULE(CRTPMTMatchingProducer)

} //end namespace

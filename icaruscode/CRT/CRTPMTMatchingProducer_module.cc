// icaruscode includes
#include "sbnobj/ICARUS/CRT/CRTData.hh"
#include "sbnobj/Common/CRT/CRTHit.hh"
#include "icaruscode/CRT/CRTUtils/CRTHitRecoAlg.h"
#include "sbnobj/Common/Trigger/ExtraTriggerInfo.h"
#include "icaruscode/IcarusObj/CRTPMTMatching.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Event.h" 
#include "canvas/Persistency/Common/Ptr.h" 
#include "canvas/Persistency/Common/PtrVector.h" 
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art_root_io/TFileService.h" 
#include "art_root_io/TFileDirectory.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Persistency/Common/PtrMaker.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "canvas/Utilities/Exception.h"

// C++ includes
#include <memory>
#include <iostream>
#include <map>
#include <iterator>
#include <algorithm>
#include <vector>

// LArSoft
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/AuxDetGeometry.h"
#include "larcorealg/Geometry/GeometryCore.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/DetectorInfoServices/LArPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorPropertiesService.h"
#include "lardata/DetectorInfoServices/DetectorClocksService.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "larcoreobj/SimpleTypesAndConstants/geo_types.h"

// ROOT
#include "TTree.h"
#include "TFile.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TVector3.h"
#include "TGeoManager.h"

using std::vector;

namespace icarus {
namespace crt {

  class CRTPMTMatchingProducer : public art::EDProducer {
  public:
 
    using CRTHit = sbn::crt::CRTHit;
    
    explicit CRTPMTMatchingProducer(fhicl::ParameterSet const & p);

    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    CRTPMTMatchingProducer(CRTPMTMatchingProducer const &) = delete;
    CRTPMTMathcingProducer(CRTPMTMatchingProducer &&) = delete;
    CRTPMTMatchingProducer & operator = (CRTPMTMatchingProducer const &) = delete; 
    CRTPMTMatchingProducer & operator = (CRTPMTMatchingProducer &&) = delete;

    // Required functions.
    void produce(art::Event & e) override;

    // Selected optional functions.
    void beginJob() override;

    void endJob() override;

    void reconfigure(fhicl::ParameterSet const & p);

  private:

	// Params from fcl file.......
	art::InputTag fCrtModuleLabel;		      	///< name of crt producer.
	art::InputTag fTriggerLabel;		        ///< name of trigger producer.
	art::InputTag fTriggerConfigurationLabel;	///< name of the trigger configuration.
    
	double fTimeOfFlightInterval;	 		///< CRTPMT time difference interval to find the match.
	int fPMTADCThresh;				///< ADC amplitude for a PMT to be considered above threshold.
	int fnOpHitToTrigger;				///< Number of OpHit above threshold to mimic the triggering PMT.
	double fBNBBeamGateMin;
	double fBNBBeamGateMax;
	double fBNBinBeamMin;
	double fBNBinBeamMax;
	double fNuMIBeamGateMin;
	double fNuMIBeamGateMax;
	double fNuMIinBeamMin;
	double fNuMIinBeamMax;

	// Trigger data product variables
	unsigned int m_gate_type;
	std::string m_gate_name;
	uint64_t m_trigger_timestamp;
	uint64_t m_gate_start_timestamp;
	uint64_t m_trigger_gate_diff;
	uint64_t m_gate_width;


	geo::GeometryCore const* fGeometryService;	///< pointer to Geometry provider

  }; // class CRTPMTMatchingProducer

  CRTPMTMatchingProducer::CRTPMTMatchingProducer(fhicl::ParameterSet const & p)
  : EDProducer{p},
      fOpFlashModuleLabel0(
          p.get<art::InputTag>("OpFlashModuleLabel0")),
      fOpFlashModuleLabel1(
          p.get<art::InputTag>("OpFlashModuleLabel1")),
      fCrtHitModuleLabel(p.get<art::InputTag>("CrtHitModuleLabel", "crthit")),
      fTriggerLabel(p.get<art::InputTag>("TriggerLabel", "daqTrigger")),
      fTriggerConfigurationLabel(
          p.get<art::InputTag>("TriggerConfiguration", "triggerconfig")),
      fnOpHitToTrigger(p.get<int>("nOpHitToTrigger")),
      fTimeOfFlightInterval(p.get<double>("TimeOfFlightInterval")),
      fPMTADCThresh(p.get<int>("PMTADCThresh")),
      fBNBBeamGateMin(p.get<double>("BNBBeamGateMin")),
      fBNBBeamGateMax(p.get<double>("BNBBeamGateMax")),
      fBNBinBeamMin(p.get<double>("BNBinBeamMin")),
      fBNBinBeamMax(p.get<double>("BNBinBeamMax")),
      fNuMIBeamGateMin(p.get<double>("NuMIBeamGateMin")),
      fNuMIBeamGateMax(p.get<double>("NuMIBeamGateMax")),
      fNuMIinBeamMin(p.get<double>("NuMIinBeamMin")),
      fNuMIinBeamMax(p.get<double>("NuMIinBeamMax")),
      fGeometryService(lar::providerFrom<geo::Geometry>()) {
  fFlashLabels = { fOpFlashModuleLabel0, fOpFlashModuleLabel1 };
  // Initialize member data here, if know don't want to reconfigure on the fly
  {
 
   // Call appropriate produces<>() functions here.
    produces< vector<CRTHit> >();
    produces< art::Assns<CRTHit, CRTData> >();
    
    reconfigure(p);

  } // CRTPMTMatchingProducer()

  void CRTPMTMatchingProducer::reconfigure(fhicl::ParameterSet const & p)
  {
    fCrtModuleLabel = (p.get<art::InputTag> ("CrtModuleLabel")); 
    fTriggerLabel   = (p.get<art::InputTag> ("TriggerLabel")); 
  } // CRTPMTMatchingProducer::reconfigure()

  void CRTPMTMatchingProducer::beginJob()
  {

  } // CRTPMTMatchingProducer::beginJob()
 
  void CRTPMTMatchingProducer::produce(art::Event & event)
  {

    std::unique_ptr< vector<CRTHit> > CRTHitcol( new vector<CRTHit>);
    std::unique_ptr< art::Assns<CRTHit, CRTData> > Hitassn( new art::Assns<CRTHit, CRTData>);
    art::PtrMaker<sbn::crt::CRTHit> makeHitPtr(event);

    int nHits = 0;

    // Retrieve list of CRT hits
    art::Handle< std::vector<CRTData>> crtListHandle;
    vector<art::Ptr<CRTData> > crtList;

    if (event.getByLabel(fCrtModuleLabel, crtListHandle))
      art::fill_ptr_vector(crtList, crtListHandle);

    //add trigger info
    if( !fTriggerLabel.empty() ) {

      art::Handle<sbn::ExtraTriggerInfo> trigger_handle;
      event.getByLabel( fTriggerLabel, trigger_handle );
      if( trigger_handle.isValid() )
      	m_trigger_timestamp = trigger_handle->triggerTimestamp; 
      else
      	mf::LogError("CRTPMTMatchingProducer") << "No raw::Trigger associated to label: " << fTriggerLabel.label() << "\n" ;
    } else{ 
      std::cout  << "Trigger Data product " << fTriggerLabel.label() << " not found!\n" ;
    }

    mf::LogInfo("CRTPMTMatchingProducer")
      <<"Number of SiPM hits = "<<crtList.size();
    //m_trigger_timestamp = event.getProduct<sbn::ExtraTriggerInfo>(fTriggerLabel).triggerTimestamp;

    mf::LogInfo("CRTPMTMatchingProducer")
      <<"Number of SiPM hits = "<<crtList.size();

    vector<art::Ptr<CRTData>> crtData = hitAlg.PreselectCRTData(crtList, m_trigger_timestamp);

    vector<std::pair<CRTHit, vector<int>>> crtHitPairs = hitAlg.CreateCRTHits(crtData, m_trigger_timestamp);
    //vector<std::pair<CRTHit, vector<int>>> crtHitPairs = hitAlg.CreateCRTHits(crtList);

    mf::LogInfo("CRTPMTMatchingProducer")
      << "Number of CRTHit,data indices pairs = " << crtHitPairs.size();

    for(auto const& crtHitPair : crtHitPairs){

      CRTHitcol->push_back(crtHitPair.first);
      art::Ptr<CRTHit> hitPtr = makeHitPtr(CRTHitcol->size()-1);
      nHits++;

      for(auto const& data_i : crtHitPair.second){

        Hitassn->addSingle(hitPtr, crtList[data_i]);
      }
    }
      
    event.put(std::move(CRTHitcol));
    event.put(std::move(Hitassn));

    mf::LogInfo("CRTSimHitProducer")
      <<"Number of CRT hits produced = "<<nHits;

  } // CRTPMTMatchingProducer::produce()

  void CRTPMTMatchingProducer::endJob()
  {

  } // CRTPMTMatchingProducer::endJob()

  DEFINE_ART_MODULE(CRTPMTMatchingProducer)

}
} //end namespace

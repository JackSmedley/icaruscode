////////////////////////////////////////////////////////////////////////
// Class:       electronfilter
// Module Type: filter
// File:        electronfilter_module.cc
//
// Generated at Fri Sep  6 04:41:23 2019 by Dominic Barker using artmod
// from cetpkgsupport v1_14_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDFilter.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>

#include "larsim/MCCheater/ParticleInventoryService.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "canvas/Persistency/Common/Ptr.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"

#include "lardata/DetectorInfoServices/DetectorClocksService.h"

namespace shower {
  class electronfilter;
}

class shower::electronfilter : public art::EDFilter {
public:
  explicit electronfilter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  electronfilter(electronfilter const &) = delete;
  electronfilter(electronfilter &&) = delete;
  electronfilter & operator = (electronfilter const &) = delete;
  electronfilter & operator = (electronfilter &&) = delete;

  // Required functions.
  bool filter(art::Event & e) override;


private:

  // Declare member data here.
  std::string fGenieGenModuleLabel;

  bool isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, const simb::MCParticle* &particle, float distance=5);

};


shower::electronfilter::electronfilter(fhicl::ParameterSet const & pset): art::EDFilter{pset}
// Initialize member data here.
{
  fGenieGenModuleLabel = pset.get<std::string>("GenieGenModuleLabel");
}

bool shower::electronfilter::filter(art::Event & evt)
{
  const art::ServiceHandle<cheat::ParticleInventoryService> particleInventory;
  
  // * MC truth information
  art::Handle<std::vector<simb::MCTruth> > mctruthListHandle;
  std::vector<art::Ptr<simb::MCTruth> > mclist;
  if (evt.getByLabel(fGenieGenModuleLabel,mctruthListHandle))
    art::fill_ptr_vector(mclist, mctruthListHandle);
  
  int electrons = 0;

  //Loop over the neutrinos 
  for(auto const& mc: mclist){

    //List the particles in the event
    const sim::ParticleList& particles = particleInventory->ParticleList();
    
    for (sim::ParticleList::const_iterator particleIt = particles.begin(); particleIt != particles.end(); ++particleIt){
      const simb::MCParticle *particle = particleIt->second;
      
      //Only keep electrons
      if(particle->PdgCode() != 11){continue;}

      //Only keep primary electrons
      if(particle->Mother() != 0){continue;}

      //Do we have any electrons from the vertex 
      if(!isFromNuVertex(mc,particle)){continue;}

      //Is the electron in the FV>

      ++electrons;

    }
  }
  
  //Only keep electron events
  if(electrons > 0){return true;}

  return false;

}
		      

bool shower::electronfilter::isFromNuVertex(const art::Ptr<simb::MCTruth>& mc, const simb::MCParticle* &particle, float distance){
  
  TLorentzVector nuVtx     = mc->GetNeutrino().Nu().Trajectory().Position(0);
  TLorentzVector partstart = particle->Position();
  return TMath::Abs((partstart - nuVtx).Mag()) < distance;
}


DEFINE_ART_MODULE(shower::electronfilter)
